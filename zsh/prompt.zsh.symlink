# ~/.dotfiles/zsh/prompt.zsh.symlink

# === Custom Prompt ===

# Git branch, sync status, and dirty flag helper function
git_prompt_info() {
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    local branch ahead=0 behind=0 dirty git_status

    # Get branch name
    branch=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)

    # Get ahead/behind counts safely
    IFS=$'\t' read -r ahead behind < <(git rev-list --left-right --count HEAD...@{u} 2>/dev/null || echo "0\t0")

    # Check for uncommitted changes
    if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
      dirty="%{$fg[red]%}*%{$reset_color%}"
    else
      dirty=""
    fi

    git_status="üå± $branch$dirty"
    (( ahead > 0 )) && git_status+=" %{$fg[green]%}‚Üë$ahead%{$reset_color%}"
    (( behind > 0 )) && git_status+=" %{$fg[yellow]%}‚Üì$behind%{$reset_color%}"

    echo "$git_status"
  fi
}

# Load Zsh colors
autoload -Uz colors && colors

# Enable prompt substitution
setopt PROMPT_SUBST

# Initialize the prompt symbol (will be updated by precmd)
PROMPT_SYMBOL="%{$fg[white]%}‚ùØ%{$reset_color%}"

# Dynamically update ‚ùØ color based on last command status
precmd() {
  # Check if this is the first time the prompt is being displayed
  if [[ -z $INITIAL_PROMPT_SHOWN ]]; then
    PROMPT_SYMBOL="%{$fg[white]%}‚ùØ%{$reset_color%}"
    INITIAL_PROMPT_SHOWN=1
    return
  fi

  # Update PROMPT_SYMBOL based on last command exit status
  if [[ $? -ne 0 ]]; then
    PROMPT_SYMBOL="%{$fg[red]%}‚ùØ%{$reset_color%}"
  else
    PROMPT_SYMBOL="%{$fg[white]%}‚ùØ%{$reset_color%}"
  fi
}

# Define the final prompt layout
PROMPT='%{$fg[cyan]%}%n@%m %{$fg[green]%}%~%{$reset_color%} $(git_prompt_info)
${PROMPT_SYMBOL} '

# Disable right prompt
RPROMPT=''
